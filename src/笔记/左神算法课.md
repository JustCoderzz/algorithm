# 左神课程笔记

## master公式

求解递归的时间复杂度：子问题的规模必须是等量的

![image-20220508140302011](C:\Users\Lu  sir\AppData\Roaming\Typora\typora-user-images\image-20220508140302011.png)

T（n）=a*T(N/b) +O(N的d次方)

其中a代表的是进行本层调用递归的次数

T(N/b)代表的是子问题的规模  比如N/2代表每次将子问题的规模平分一半

O(N的d次方)代表的是 除了子问题的递归剩下的时间复杂度是多少



## 快排的多种写法

### 快排1.0

最坏情况下是O（n的平方）

保证的是小于等于我们的Key的全在左边，大于的在右边

### 快排2.0

最坏情况下是O（n的平方）

保证小于Key的数一定在该key的左边，也就是分成了三部分

### 快排3.0

就是使用随机取得我们的标志key，所有概率累加，数学的长期期望，得到的是O（n*logn)的算法

额外空间复杂度  最好是logN  最坏是N



## 堆

堆的调整都是O（logN），因为每次都是只走树的一个分支

插入一个新节点时，就是不断的判断该节点与它的父节点之前的大小关系，如果大于就不断的替换

移除一个最大值，重新堆化的过程就是，父节点不断的跟两个孩子作比较，若孩子节点大于了父节点的值则进行交换，否则就停止，堆化完成。

时间复杂度是O（N*logN）   空间复杂度是O（1）



## 排序算法

之前的排序都是基于比较的排序   不基于比较的排序都是要根据数据状况来定

排序算法的稳定性就是同样值得个体之间，如果不因为排序而改变相对次序，就说这个排序是具有稳定性的。



